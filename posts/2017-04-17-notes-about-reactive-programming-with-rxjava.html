<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="this is my note taking app, shared with everybody"/><meta property="og:image" content="https://og-image.now.sh/Welcome%20to%20the%20Invasion%20Of%20Small%20Cubes.png?theme=dark&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="og:title" content="Welcome to the Invasion Of Small Cubes"/><meta name="twitter:card" content="summary_large_image"/><script src="tracking.js"></script><title>Notes About Reactive Programming With RxJava</title><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/8549f512080405e68560.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8549f512080405e68560.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8940758a4d427170012c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8940758a4d427170012c.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-27ce3cd164fb94df60e7.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.44ec10f6e415a8ca6263.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-e21097dd67dbafb50e0f.js" as="script"/><link rel="preload" href="/_next/static/chunks/10cf003e655e7be2119574cd9202224517114f06.141ecfc5fd01254381c9.js" as="script"/><link rel="preload" href="/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.1bed55e3a27ef4b763d1.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bid%5D-26b94c598112f16fa107.js" as="script"/></head><body><div id="__next"><div class="layout_container__2t4v2"><header class="layout_header__2rhWq"><a href="/"><img src="/images/face.jpeg" class="layout_headerImage__2h5On utils_borderCircle__13qdJ" alt="The Invasion of Small Cubes"/></a><h2 class="utils_headingLg__de7p0"><a class="utils_colorInherit__3Gudf" href="/">The Invasion of Small Cubes</a></h2></header><main><article><h1 class="utils_headingXl__1XecN">Notes About Reactive Programming With RxJava</h1><div class="utils_lightText__12Ckm"><time dateTime="2017-04-17">April 17, 2017</time></div><div><p>Central to RxJava is the <code>Observable</code> type that represents a stream of data or events.</p><p>The entire point of RxJava being reactive, is to support push. To support push <code>Observable</code> and <code>Observer</code> connect via subscription.</p><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>interface Observable&lt;T&gt; {
</span>  Subscription subscribe(Observer s);
<!-- -->}
</code></pre><p>Once subscription is made, streams of data are handled using the following interface</p><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>interface Observer&lt;T&gt; {
</span>  void onNext(T t);
<!-- -->  void onError(Throwable t);
<!-- -->  void onCompleted();
<!-- -->}
</code></pre><p><code>onError</code> and <code>onCompleted</code> are terminal events and only one of them can happen (if the stream is not infinite).</p><p>An <code>Observable</code>, by default, is synchronous. Although it&#x27;s bad to use an Observable with synchronous blocking I/O. It&#x27;s generally not always wrong to use a synchronous <code>Observable</code>. For example, if we retrieve data from a cache, it doesn&#x27;t make sense to add complexity to the code with asynchronous behavior because a cache has a lookup time of micro/nano seconds.</p><p>The actual criteria to decide about how we should implement our <code>Observable</code>, is whether the event production is blocking or not blocking.</p><p>That being said, most <code>Observable</code> functions pipeline are synchronous (map, filter, ...) because we want to produce the event stream but then we want to run computation on them. This will guarantee us efficiency and will avoid nondeterministic behavior due to scheduling, context switching and so on.</p><p>Parallelism is simultaneous execution of tasks, tipically on different CPUs or machines. Concurrency, on the other hand, is the composition or interleaving of multiple tasks.</p><p>The contract of <code>Observable</code> is that events (<code>onNext()</code>, <code>onCompleted()</code>,<code>onError()</code>) can never be emitted concurrently. Allowing concurrent <code>Observable</code> streams (with concurrent <code>onNext()</code>) would limit the types of events that can be processed and required thread-safe data structures. Is also slower to do generic fine-grained parallelism.</p><p>It is far more efficient to synchronously execute on a single thread and take advantage of the many memory and CPU optimizations for sequential computation. On a list is quite is to reason in this way but a stream does not know the work ahead of time, it just receives data via <code>onNext()</code> and therefore cannot automatically chunk the work.</p><p>The <code>Observable</code> type is lazy, meaning it does nothing until it is subscribed to. With lazyiness is possible to compose <code>Observable</code> together. Creating one does not actually cause any work to happen. The work will happen once subscribed. Being lazy also allows that a particular instance can be invoked more than once.</p><p>An <code>Observable</code> is the <em>dual</em> of an <code>Iterable</code>. It push instead of pull. Besides that, the same programming model can be applied by both:</p><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>getDataFromMemory(). // return Stream&lt;String&gt;
</span>// OR
<!-- -->getDataAsynch(). // Observable&lt;String&gt;
<!-- -->.skip(10)
<!-- -->.limit(5)
<!-- -->.map(s -&gt; s + &quot;_transformed&quot;)
<!-- -->.forEach(System::out::println)
</code></pre><p><code>rx.Observable&lt;T&gt;</code> is the abstraction is going to be used all the time. An <code>Observable</code> can produce an
arbitrary number of events. It can produce:</p><ul><li>Values of type T, as declared by <code>Observable</code></li><li>Completion events</li><li>Error event</li></ul><p>An instance of <code>Observable</code> does not emit any events until someone is actually interested in receiving them (this are called <em>cold</em> <code>Observable</code>).</p><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>tweets.subscribe(
</span>    (Tweet tweet) -&gt; { System.out.println(tweet); },
<!-- -->    (Throwable t) -&gt; { t.printStackTrace(); }
<!-- -->  );
</code></pre><p>It&#x27;s guaranteed that no other Tweet will be emitted after the exception.</p><p>By default Observable runs on current thread if not otherwise specified:</p><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>Observable&lt;Integer&gt; ints = Observable.create(
</span>        subscriber -&gt; {
<!-- -->            log(&quot;CREATE&quot;);
<!-- -->            subscriber.onNext(5);
<!-- -->            subscriber.onNext(6);
<!-- -->            subscriber.onNext(7);
<!-- -->            subscriber.onCompleted();
<!-- -->            log(&quot;COMPLETED&quot;);
<!-- -->        }
<!-- -->);
<!-- -->log(&quot;STARTING&quot;);
<!-- -->ints.subscribe( i -&gt; log(&quot;Element&quot;+ i) );
<!-- -->log(&quot;FINISHED&quot;);
</code></pre><p>This will print out:</p><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>main: STARTING
</span>main: CREATE
<!-- -->main: Element5
<!-- -->main: Element6
<!-- -->main: Element7
<!-- -->main: COMPLETED
<!-- -->main: FINISHED
</code></pre><p>We can implement others <code>Observable</code> constructors as <code>create</code>:</p><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>static &lt;T&gt; Observable&lt;T&gt; just(T t) {
</span>    return Observable.create(
<!-- -->            s -&gt; {
<!-- -->                s.onNext(t);
<!-- -->                s.onCompleted();
<!-- -->            }
<!-- -->    );
<!-- -->}
<!-- -->
<!-- -->static &lt;T&gt; Observable&lt;T&gt; never() {
<!-- -->    return Observable.create(
<!-- -->            s -&gt; {}
<!-- -->    );
<!-- -->}
<!-- -->
<!-- -->static &lt;T&gt; Observable&lt;T&gt; empty() {
<!-- -->    return Observable.create(
<!-- -->            s -&gt; {
<!-- -->                s.onCompleted();
<!-- -->            }
<!-- -->    );
<!-- -->}
<!-- -->
<!-- -->static Observable&lt;Integer&gt; range(Integer from, Integer to) {
<!-- -->    return Observable.create(
<!-- -->            s -&gt; {
<!-- -->                IntStream.range(from, to).forEach( i -&gt; s.onNext(i));
<!-- -->                s.onCompleted();
<!-- -->            }
<!-- -->    );
<!-- -->}
</code></pre><p>Every time we call <code>subscribe()</code>, the subscrition handler inside <code>create</code> is invoked. If you want to avoid call
create every time, you can use <code>cache()</code> that will give events already computed. Of course if stream is infinite, using <code>cache()</code> will kill a kitten.</p><p>To produce infinite streams it&#x27;s not really convenient calling the computation inside the client thread, but rather start a new thread that will handle the computation. For how long should we keep computing stuff?</p><p>It is advised to use the method <code>isUnsubscribed()</code> to check if we have subscribers listening:</p><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>static Observable&lt;BigInteger&gt; naturalNumbers() {
</span>    return Observable.create(
<!-- -->            s -&gt; {
<!-- -->                Runnable r = () -&gt; {
<!-- -->                    BigInteger i = BigInteger.ZERO;
<!-- -->                    while(!s.isUnsubscribed()) {
<!-- -->                        s.onNext(i);
<!-- -->                        i = i.add(BigInteger.ONE);
<!-- -->                    }
<!-- -->                };
<!-- -->                Thread thread = new Thread(r);
<!-- -->                thread.start();
<!-- -->                s.add(Subscriptions.create(thread::interrupt));
<!-- -->            });
<!-- -->}
</code></pre><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>Subscription subscribe = naturalNumbers()
</span>        .subscribe(System.out::println,
<!-- -->          e -&gt; System.out.println(e.getMessage())); // not triggered
<!-- -->
<!-- -->// do something else [...]
<!-- -->
<!-- -->    subscribe.unsubscribe();
</code></pre><p>Between the check of isUnsubscribed and the actual computation we could have also seconds to wait because the computation could be really big.</p><p>Passing thread::interrupt to the subscription allows you to quit as soon as possible without wasting time.
Be Aware that this will not trigger the <code>onError</code>. Subscription will end gracefully.</p><p>You cannot call the <code>onNext</code> from multiple threads. Don&#x27;t do it, it violates Rx principles.</p><p>The class <code>Observable</code> has two useful methods: <code>timer</code> and <code>interval</code>.</p><p>The first one is like the method <code>sleep</code>, the latter instread emits at a fixed rate some element.</p><p>A cold <code>Observable</code> is lazy and doesn&#x27;t emits until someone subscribes. This implies that every subscriber has its own copy of the stream because for every subscription the method <code>create</code> as mentioned above. Generally speaking a cold <code>Observable</code> involves some side effect like connecting to a database.</p><p>Hot <code>Observable</code> are independent from consumers, they emits even if there is no subscriber. At a certain point, when a subscriber subscribes, it will receive events that are being currently being emitted. An example of hot <code>Observable</code> is for example mouse events.</p><p>An example of hot subscriber can be seen via the method <code>publish</code> from <code>Observable</code>.
An example of what (to me seems) an almost cold subscriber can be seen via <code>share()</code>.</p><p>Given:</p><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>private static void refCount(Observable&lt;Status&gt; observable) {
</span>    Observable&lt;Status&gt; observable1 = observable.share(); // or observable.publish().refCount();
<!-- -->
<!-- -->    System.out.println(&quot;Subscribe1&quot;);
<!-- -->    Subscription subscribe1 = observable1.subscribe();
<!-- -->
<!-- -->    System.out.println(&quot;Subscribe2&quot;);
<!-- -->    Subscription subscribe2 = observable1.subscribe();
<!-- -->
<!-- -->    System.out.println(&quot;Unsubscribe1&quot;);
<!-- -->    subscribe1.unsubscribe();
<!-- -->
<!-- -->    System.out.println(&quot;Unsubscribe2&quot;);
<!-- -->    subscribe2.unsubscribe();
<!-- -->
<!-- -->}
<!-- -->
<!-- -->private static void publish(Observable&lt;Status&gt; observable) {
<!-- -->    ConnectableObservable&lt;Status&gt; publish = observable.publish();
<!-- -->
<!-- -->    System.out.println(&quot;Subscribe1&quot;);
<!-- -->    Subscription subscribe1 = publish.subscribe();
<!-- -->
<!-- -->    System.out.println(&quot;Subscribe2&quot;);
<!-- -->    Subscription subscribe2 = publish.subscribe();
<!-- -->
<!-- -->    Subscription connect = publish.connect();
<!-- -->
<!-- -->    System.out.println(&quot;Unsubscribe1&quot;);
<!-- -->    subscribe1.unsubscribe();
<!-- -->
<!-- -->    System.out.println(&quot;Unsubscribe2&quot;);
<!-- -->    subscribe2.unsubscribe();
<!-- -->
<!-- -->    System.out.println(&quot;Disposing connection&quot;);
<!-- -->    connect.unsubscribe();
<!-- -->}
</code></pre><p>Running:</p><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>System.out.println(&quot;with Share:&quot;);
</span>refCount(observable);
<!-- -->System.out.println(&quot;&quot;);
<!-- -->System.out.println(&quot;with Publish:&quot;);
<!-- -->publish(observable);
</code></pre><p>You get this output:</p><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>with Share:
</span>Subscribe1
<!-- -->Connecting...
<!-- -->Subscribe2
<!-- -->Unsubscribe1
<!-- -->Unsubscribe2
<!-- -->Disconnecting...
<!-- -->
<!-- -->with Publish:
<!-- -->Subscribe1
<!-- -->Subscribe2
<!-- -->Connecting...
<!-- -->Unsubscribe1
<!-- -->Unsubscribe2
<!-- -->Disposing connection
<!-- -->Disconnecting...
</code></pre><p>There are many operators.</p><p>One interesting thing is:</p><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>System.out.println(&quot;SCAN&quot;);
</span>Observable.just(1,2,3).scan((total, chunk) -&gt; total+chunk).subscribe(out::println);
<!-- -->System.out.println(&quot;REDUCE&quot;);
<!-- -->Observable.just(1,2,3).reduce((total, chunk) -&gt; total+chunk).subscribe(out::println);
</code></pre><p>and the output is:</p><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>SCAN
</span>1
<!-- -->3
<!-- -->6
<!-- -->REDUCE
<!-- -->6
</code></pre><p>Keep in mind that in case of infinite stream <code>scan</code> will keep emitting whereas reduce will never emit. If we use <code>distinct</code>, this will cause problems because it caches every event generated.</p><p>You can do this: <code>concat(fromCache, fromDb).first()</code> and just call <code>fromDb</code> only when element is not present in cache!! (<code>concat is lazy!</code>)</p><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>Observable&lt;String&gt; fromCacheEmpty = Observable.empty();
</span>Observable&lt;String&gt; fromCacheOneElem = Observable.just(&quot;1&quot;);
<!-- -->Observable&lt;String&gt; fromCacheNElem = Observable.just(&quot;1&quot;, &quot;3&quot;);
<!-- -->Observable&lt;String&gt; fromDb = Observable.just(&quot;2&quot;);
<!-- -->
<!-- -->System.out.println(&quot;EMPTY -&gt; DB&quot;);
<!-- -->Observable.concat(fromCacheEmpty, fromDb).first().subscribe(out::println);
<!-- -->System.out.println(&quot;CACHE1 -&gt; NODB&quot;);
<!-- -->Observable.concat(fromCacheOneElem, fromDb).first().subscribe(out::println);
<!-- -->System.out.println(&quot;CACHE2 -&gt; DB&quot;);
<!-- -->Observable.concat(fromCacheNElem, fromDb).first().subscribe(out::println);
</code></pre><p>with output:</p><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>EMPTY -&gt; DB
</span>2
<!-- -->CACHE1 -&gt; NODB
<!-- -->1
<!-- -->CACHE2 -&gt; DB
<!-- -->1
</code></pre><p>Read on the chapter about <code>concat</code>, <code>merge</code> and <code>switchOnNext</code> starting on page 97. It&#x27;s so cool.</p><p>Want to do event sourcing with RxJava? Done!</p><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>eventStore
</span>.observe()
<!-- -->.groupBy(event::uuid)
<!-- -->.subscribe( uuid -&gt; uuid.subscribe(this::updateProjection));
</code></pre><p>You can use <code>observeOn</code> and <code>subScribeOn</code> to move on different thread the computation and the subscription of your flow of data. <code>subscribeOn</code> allows you to tell on which thread you want to push events down to your stream. A common use case is to process the stream on the the background but emit it on another thread (common example is to do heavy computation on the backend and observe on the UI thread). In this case you can use the <code>observeOn</code> method.</p><p>You can also achieve parallelism with this feature but keep in mind that you need to take care of how much parallelism your system can handle. <code>flatMap</code> method has an overloaded method that allows you to control parallelism. You have many <code>Schedulers</code> from which you can get threads. Remember that <code>io()</code> will spawn new threads if existing ones are being used whereas <code>computation()</code> has CPU-bound threads.</p><p>To recap:</p><ul><li><code>Observable</code> without <code>subscribeOn</code> will work like a single threaded program with blocking calls</li><li><code>Observable</code> with <code>subscribeOn</code> will start a thread on background where the work is done (inside the thread still sequential calls)</li><li><code>Observable</code> using <code>flatMap</code> and inside it <code>subscribeOn</code> will start a new thread for each <code>Observable</code></li></ul><p>Another concept really important with reactive programming is <em>backpressure</em>. In every system based on message passing, the problem of the consumer not
consuming fast enough can be present. If the consumer is able to give a feedback to the producer, the producer now can control how much it&#x27;s producing (although if you have a hot producer, that could be not true).</p><p>Many operators have backpressure built-in so there is no need to worry about it. If you have to produce from scratch a producer, you can use <code>SyncOnSubscribe.createStatless|createStateful</code> (there is also the Async version). Don&#x27;t use <code>create</code> from <code>Observable</code> because you won&#x27;t have backpressure on it.</p><p>To know about testing, you can read about it <a href="https://www.infoq.com/articles/Testing-RxJava">here</a></p> </div></article></main><div class="layout_backToHome__1vZsp"><a href="/">← Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"2017-04-17-notes-about-reactive-programming-with-rxjava","c":"Central to RxJava is the `Observable` type that represents a stream of data or events.\n\nThe entire point of RxJava being reactive, is to support push. To support push `Observable` and `Observer` connect via subscription.\n\n```\ninterface Observable\u003cT\u003e {\n  Subscription subscribe(Observer s);\n}\n```\n\nOnce subscription is made, streams of data are handled using the following interface\n\n```\ninterface Observer\u003cT\u003e {\n  void onNext(T t);\n  void onError(Throwable t);\n  void onCompleted();\n}\n```\n\n`onError` and `onCompleted` are terminal events and only one of them can happen (if the stream is not infinite).\n\nAn `Observable`, by default, is synchronous. Although it's bad to use an Observable with synchronous blocking I/O. It's generally not always wrong to use a synchronous `Observable`. For example, if we retrieve data from a cache, it doesn't make sense to add complexity to the code with asynchronous behavior because a cache has a lookup time of micro/nano seconds.\n\nThe actual criteria to decide about how we should implement our `Observable`, is whether the event production is blocking or not blocking.\n\nThat being said, most `Observable` functions pipeline are synchronous (map, filter, ...) because we want to produce the event stream but then we want to run computation on them. This will guarantee us efficiency and will avoid nondeterministic behavior due to scheduling, context switching and so on.\n\nParallelism is simultaneous execution of tasks, tipically on different CPUs or machines. Concurrency, on the other hand, is the composition or interleaving of multiple tasks.\n\nThe contract of `Observable` is that events (`onNext()`, `onCompleted()`,`onError()`) can never be emitted concurrently. Allowing concurrent `Observable` streams (with concurrent `onNext()`) would limit the types of events that can be processed and required thread-safe data structures. Is also slower to do generic fine-grained parallelism.\n\nIt is far more efficient to synchronously execute on a single thread and take advantage of the many memory and CPU optimizations for sequential computation. On a list is quite is to reason in this way but a stream does not know the work ahead of time, it just receives data via `onNext()` and therefore cannot automatically chunk the work.\n\nThe `Observable` type is lazy, meaning it does nothing until it is subscribed to. With lazyiness is possible to compose `Observable` together. Creating one does not actually cause any work to happen. The work will happen once subscribed. Being lazy also allows that a particular instance can be invoked more than once.\n\nAn `Observable` is the *dual* of an `Iterable`. It push instead of pull. Besides that, the same programming model can be applied by both:\n\n```\ngetDataFromMemory(). // return Stream\u003cString\u003e\n// OR\ngetDataAsynch(). // Observable\u003cString\u003e\n.skip(10)\n.limit(5)\n.map(s -\u003e s + \"_transformed\")\n.forEach(System::out::println)\n```\n\n`rx.Observable\u003cT\u003e` is the abstraction is going to be used all the time. An `Observable` can produce an\narbitrary number of events. It can produce:\n- Values of type T, as declared by `Observable`\n- Completion events\n- Error event\n\nAn instance of `Observable` does not emit any events until someone is actually interested in receiving them (this are called *cold* `Observable`).\n\n```\ntweets.subscribe(\n    (Tweet tweet) -\u003e { System.out.println(tweet); },\n    (Throwable t) -\u003e { t.printStackTrace(); }\n  );\n```\n\nIt's guaranteed that no other Tweet will be emitted after the exception.\n\nBy default Observable runs on current thread if not otherwise specified:\n\n```\nObservable\u003cInteger\u003e ints = Observable.create(\n        subscriber -\u003e {\n            log(\"CREATE\");\n            subscriber.onNext(5);\n            subscriber.onNext(6);\n            subscriber.onNext(7);\n            subscriber.onCompleted();\n            log(\"COMPLETED\");\n        }\n);\nlog(\"STARTING\");\nints.subscribe( i -\u003e log(\"Element\"+ i) );\nlog(\"FINISHED\");\n```\n\nThis will print out:\n\n```\nmain: STARTING\nmain: CREATE\nmain: Element5\nmain: Element6\nmain: Element7\nmain: COMPLETED\nmain: FINISHED\n```\n\nWe can implement others `Observable` constructors as `create`:\n\n```\nstatic \u003cT\u003e Observable\u003cT\u003e just(T t) {\n    return Observable.create(\n            s -\u003e {\n                s.onNext(t);\n                s.onCompleted();\n            }\n    );\n}\n\nstatic \u003cT\u003e Observable\u003cT\u003e never() {\n    return Observable.create(\n            s -\u003e {}\n    );\n}\n\nstatic \u003cT\u003e Observable\u003cT\u003e empty() {\n    return Observable.create(\n            s -\u003e {\n                s.onCompleted();\n            }\n    );\n}\n\nstatic Observable\u003cInteger\u003e range(Integer from, Integer to) {\n    return Observable.create(\n            s -\u003e {\n                IntStream.range(from, to).forEach( i -\u003e s.onNext(i));\n                s.onCompleted();\n            }\n    );\n}\n```\n\nEvery time we call `subscribe()`, the subscrition handler inside `create` is invoked. If you want to avoid call\ncreate every time, you can use `cache()` that will give events already computed. Of course if stream is infinite, using `cache()` will kill a kitten.\n\nTo produce infinite streams it's not really convenient calling the computation inside the client thread, but rather start a new thread that will handle the computation. For how long should we keep computing stuff?\n\nIt is advised to use the method `isUnsubscribed()` to check if we have subscribers listening:\n\n```\nstatic Observable\u003cBigInteger\u003e naturalNumbers() {\n    return Observable.create(\n            s -\u003e {\n                Runnable r = () -\u003e {\n                    BigInteger i = BigInteger.ZERO;\n                    while(!s.isUnsubscribed()) {\n                        s.onNext(i);\n                        i = i.add(BigInteger.ONE);\n                    }\n                };\n                Thread thread = new Thread(r);\n                thread.start();\n                s.add(Subscriptions.create(thread::interrupt));\n            });\n}\n```\n\n```\nSubscription subscribe = naturalNumbers()\n        .subscribe(System.out::println,\n          e -\u003e System.out.println(e.getMessage())); // not triggered\n\n// do something else [...]\n\n    subscribe.unsubscribe();\n```\n\nBetween the check of isUnsubscribed and the actual computation we could have also seconds to wait because the computation could be really big.\n\nPassing thread::interrupt to the subscription allows you to quit as soon as possible without wasting time.\nBe Aware that this will not trigger the `onError`. Subscription will end gracefully.\n\nYou cannot call the `onNext` from multiple threads. Don't do it, it violates Rx principles.\n\nThe class `Observable` has two useful methods: `timer` and `interval`.\n\nThe first one is like the method `sleep`, the latter instread emits at a fixed rate some element.\n\nA cold `Observable` is lazy and doesn't emits until someone subscribes. This implies that every subscriber has its own copy of the stream because for every subscription the method `create` as mentioned above. Generally speaking a cold `Observable` involves some side effect like connecting to a database.\n\nHot `Observable` are independent from consumers, they emits even if there is no subscriber. At a certain point, when a subscriber subscribes, it will receive events that are being currently being emitted. An example of hot `Observable` is for example mouse events.\n\nAn example of hot subscriber can be seen via the method `publish` from `Observable`.\nAn example of what (to me seems) an almost cold subscriber can be seen via `share()`.\n\nGiven:\n\n```\nprivate static void refCount(Observable\u003cStatus\u003e observable) {\n    Observable\u003cStatus\u003e observable1 = observable.share(); // or observable.publish().refCount();\n\n    System.out.println(\"Subscribe1\");\n    Subscription subscribe1 = observable1.subscribe();\n\n    System.out.println(\"Subscribe2\");\n    Subscription subscribe2 = observable1.subscribe();\n\n    System.out.println(\"Unsubscribe1\");\n    subscribe1.unsubscribe();\n\n    System.out.println(\"Unsubscribe2\");\n    subscribe2.unsubscribe();\n\n}\n\nprivate static void publish(Observable\u003cStatus\u003e observable) {\n    ConnectableObservable\u003cStatus\u003e publish = observable.publish();\n\n    System.out.println(\"Subscribe1\");\n    Subscription subscribe1 = publish.subscribe();\n\n    System.out.println(\"Subscribe2\");\n    Subscription subscribe2 = publish.subscribe();\n\n    Subscription connect = publish.connect();\n\n    System.out.println(\"Unsubscribe1\");\n    subscribe1.unsubscribe();\n\n    System.out.println(\"Unsubscribe2\");\n    subscribe2.unsubscribe();\n\n    System.out.println(\"Disposing connection\");\n    connect.unsubscribe();\n}\n```\n\nRunning:\n\n```\nSystem.out.println(\"with Share:\");\nrefCount(observable);\nSystem.out.println(\"\");\nSystem.out.println(\"with Publish:\");\npublish(observable);\n```\n\nYou get this output:\n\n```\nwith Share:\nSubscribe1\nConnecting...\nSubscribe2\nUnsubscribe1\nUnsubscribe2\nDisconnecting...\n\nwith Publish:\nSubscribe1\nSubscribe2\nConnecting...\nUnsubscribe1\nUnsubscribe2\nDisposing connection\nDisconnecting...\n```\n\nThere are many operators.\n\nOne interesting thing is:\n\n```\nSystem.out.println(\"SCAN\");\nObservable.just(1,2,3).scan((total, chunk) -\u003e total+chunk).subscribe(out::println);\nSystem.out.println(\"REDUCE\");\nObservable.just(1,2,3).reduce((total, chunk) -\u003e total+chunk).subscribe(out::println);\n```\n\nand the output is:\n\n```\nSCAN\n1\n3\n6\nREDUCE\n6\n```\n\nKeep in mind that in case of infinite stream `scan` will keep emitting whereas reduce will never emit. If we use `distinct`, this will cause problems because it caches every event generated.\n\nYou can do this: `concat(fromCache, fromDb).first()` and just call `fromDb` only when element is not present in cache!! (`concat is lazy!`)\n\n```\nObservable\u003cString\u003e fromCacheEmpty = Observable.empty();\nObservable\u003cString\u003e fromCacheOneElem = Observable.just(\"1\");\nObservable\u003cString\u003e fromCacheNElem = Observable.just(\"1\", \"3\");\nObservable\u003cString\u003e fromDb = Observable.just(\"2\");\n\nSystem.out.println(\"EMPTY -\u003e DB\");\nObservable.concat(fromCacheEmpty, fromDb).first().subscribe(out::println);\nSystem.out.println(\"CACHE1 -\u003e NODB\");\nObservable.concat(fromCacheOneElem, fromDb).first().subscribe(out::println);\nSystem.out.println(\"CACHE2 -\u003e DB\");\nObservable.concat(fromCacheNElem, fromDb).first().subscribe(out::println);\n```\n\nwith output:\n\n```\nEMPTY -\u003e DB\n2\nCACHE1 -\u003e NODB\n1\nCACHE2 -\u003e DB\n1\n```\n\nRead on the chapter about `concat`, `merge` and `switchOnNext` starting on page 97. It's so cool.\n\nWant to do event sourcing with RxJava? Done!\n\n```\neventStore\n.observe()\n.groupBy(event::uuid)\n.subscribe( uuid -\u003e uuid.subscribe(this::updateProjection));\n```\n\nYou can use `observeOn` and `subScribeOn` to move on different thread the computation and the subscription of your flow of data. `subscribeOn` allows you to tell on which thread you want to push events down to your stream. A common use case is to process the stream on the the background but emit it on another thread (common example is to do heavy computation on the backend and observe on the UI thread). In this case you can use the `observeOn` method.\n\nYou can also achieve parallelism with this feature but keep in mind that you need to take care of how much parallelism your system can handle. `flatMap` method has an overloaded method that allows you to control parallelism. You have many `Schedulers` from which you can get threads. Remember that `io()` will spawn new threads if existing ones are being used whereas `computation()` has CPU-bound threads.\n\nTo recap:\n\n* `Observable` without `subscribeOn` will work like a single threaded program with blocking calls\n* `Observable` with `subscribeOn` will start a thread on background where the work is done (inside the thread still sequential calls)\n* `Observable` using `flatMap` and inside it `subscribeOn` will start a new thread for each `Observable`\n\nAnother concept really important with reactive programming is *backpressure*. In every system based on message passing, the problem of the consumer not\nconsuming fast enough can be present. If the consumer is able to give a feedback to the producer, the producer now can control how much it's producing (although if you have a hot producer, that could be not true).\n\nMany operators have backpressure built-in so there is no need to worry about it. If you have to produce from scratch a producer, you can use `SyncOnSubscribe.createStatless|createStateful` (there is also the Async version). Don't use `create` from `Observable` because you won't have backpressure on it.\n\nTo know about testing, you can read about it [here](https://www.infoq.com/articles/Testing-RxJava)\n","title":"Notes About Reactive Programming With RxJava","date":"2017-04-17"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2017-04-17-notes-about-reactive-programming-with-rxjava"},"buildId":"yY1h3sYikh6KA8TpPbY__","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-fa276ba060a4a8ac7eef.js"></script><script src="/_next/static/chunks/main-27ce3cd164fb94df60e7.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.44ec10f6e415a8ca6263.js" async=""></script><script src="/_next/static/chunks/pages/_app-e21097dd67dbafb50e0f.js" async=""></script><script src="/_next/static/chunks/10cf003e655e7be2119574cd9202224517114f06.141ecfc5fd01254381c9.js" async=""></script><script src="/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.1bed55e3a27ef4b763d1.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-26b94c598112f16fa107.js" async=""></script><script src="/_next/static/yY1h3sYikh6KA8TpPbY__/_buildManifest.js" async=""></script><script src="/_next/static/yY1h3sYikh6KA8TpPbY__/_ssgManifest.js" async=""></script></body></html>