<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="this is my note taking app, shared with everybody"/><meta property="og:image" content="https://og-image.now.sh/Welcome%20to%20the%20Invasion%20Of%20Small%20Cubes.png?theme=dark&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="og:title" content="Welcome to the Invasion Of Small Cubes"/><meta name="twitter:card" content="summary_large_image"/><script src="tracking.js"></script><title>William Kennedy - Ultimate Go Training - Workshop@MTC-KBH - notes day 1</title><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/2bbd15b4a7b85fc4.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2bbd15b4a7b85fc4.css" data-n-g=""/><link rel="preload" href="/_next/static/css/05087ab0567252a9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/05087ab0567252a9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-11be7a5831576890.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f35537586aa9f5dd.js" defer=""></script><script src="/_next/static/chunks/996-c5e5aa4c30f33066.js" defer=""></script><script src="/_next/static/chunks/358-14c60bb94e9d94b9.js" defer=""></script><script src="/_next/static/chunks/448-a35b4b9d2585f9d8.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-f8e9d146746c39b1.js" defer=""></script><script src="/_next/static/z8YvEejwlsmElDyNOqCaY/_buildManifest.js" defer=""></script><script src="/_next/static/z8YvEejwlsmElDyNOqCaY/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="layout_container__fbLkO"><header class="layout_header__kY0Lt"><a href="/"><img src="/images/face.jpeg" class="layout_headerImage__b37zH utils_borderCircle__s2nTm" alt="The Invasion of Small Cubes"/></a><h2 class="utils_headingLg__5535D"><a class="utils_colorInherit__mSH_x" href="/">The Invasion of Small Cubes</a></h2></header><main><article><h1 class="utils_headingXl__u25Y2">William Kennedy - Ultimate Go Training - Workshop@MTC-KBH - notes day 1</h1><div class="utils_lightText__eUzGY"><time dateTime="2019-02-13">February 13, 2019</time></div><div><h1><a href="https://github.com/ardanlabs/gotraining">Workshop Link</a></h1>
<ul>
<li>external latency will give you problems</li>
<li>microservices is a people problem, not a technical problem</li>
<li>garbage collection will give you a problem in performance but you need it</li>
<li>internal latency due to syncronization</li>
<li>how you acess data will affect your performance</li>
<li>logs will give you observability</li>
</ul>
<p><em>DO NOT USE A DEBUGGER, USE OBSERVABILITY.</em>
Develop a mental mode of your code, don&#x27;t use a debugger, use a logs.</p>
<p>The go runtime is not a VM, it has many stuff (like gc) but it&#x27;s not a VM.</p>
<ul>
<li>first priority integrity</li>
<li>second priority is to avoid to consume resources</li>
</ul>
<p>When you mutate memory =&gt; when bugs happen.</p>
<p>Go syntax comes from Pascal syntax.</p>
<p>Will work with the value of the data and with the value of the address of that data.
Data is both value and address.</p>
<p>You have both value semantics and pointer semantics.
Value semantics means that every piece of code has is own copy, data locality comes from value semantics.</p>
<p>With value semantics we can isolate mutation.</p>
<p>Value semantics will come at a cost, it will be inefficient.
With pointer semantics you have side effects but it&#x27;s more efficient.</p>
<p>Go always pass by copy, but you can pass the value of the address by copy.</p>
<p>Factory functions to create structs</p>
<h2>V1</h2>
<pre><div style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code class="language-golang" style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>func createUserV1() user { // We&#x27;re using value semantic
</span>    u := user { name: &quot;bill&quot;, email: &quot;something@mail.com&quot;}
<!-- -->    return u
<!-- -->}</code></div></pre>
<h2>V2</h2>
<pre><div style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code class="language-golang" style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>func createUserV1() *user { // We&#x27;re using pointer semantic
</span>    u := user { name: &quot;bill&quot;, email: &quot;something@mail.com&quot;}
<!-- -->    println(&quot;V2&quot;, &amp;u)
<!-- -->    return &amp;u
<!-- -->}</code></div></pre>
<p>Construction on line 47, you don&#x27;t know where the construction is.
On line 48 we are sharing down on the call stack so it&#x27;s safe.
What happens when we go up? (line 49)
On line 49 we are putting the variable on the heap because it&#x27;s pointer semantics.
We should avoid the non productive allocations.
Tthe garbage collection will get involved.</p>
<p>Don&#x27;t use empty literal constructions, use <code>var</code> declaration for zero values struct construction.</p>
<p>Don&#x27;t do</p>
<pre><div style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code class="language-golang" style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>func a() *user {
</span>    a := &amp;model{}
<!-- -->    return a
<!-- -->}</code></div></pre>
<p>at construction time. It hides stuff.</p>
<p>To understand escape analysis <a href="http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html">click here</a></p>
<p>Go doesn&#x27;t have optimization for recurion nor tail recursion.</p>
<p>We need to control the gap for garbage collection. We want to use small heap to consume less resources.
Don&#x27;t make the gap larger, reduce the memory footprint (because you can reduce it usually).</p>
<p>The GC uses go routines, so it needs CPU capacity that won&#x27;t be used by your software.
The GC needs to use stop the world time to clean stuff because you can&#x27;t write while cleaning.</p>
<p>The go routine needs to go to a safe point before starting a stop the world. (it happens when the gorouting makes a function call)</p>
<p>You must make user that your code makes function call in a reasonable amount of time.</p>
<p>The goal is to increase the throughtput in between garbage collection.
Another way of doing it is to reduce the pointer semantics.</p>
<h2>How do you access data</h2>
<p>When you run a benchmark, you machine must be idle, if it&#x27;s not idle you will have the wrong output. Needs to be idle.
Don&#x27;t run benchmark on cloud computers, too much noise.
Find a value B.N (banchmark value) so that the cycle will be run for the entire benchmark cycle.
The hardware also uses value semantics. (L1, L2, L3)</p>
<p>Unless there is no good reason, always use slice of values to give memory continuity.
We always use use slices and array and there is no linked list because slice and array are performant.</p>
<p>You can use whatever structure you want, but when you need optmization, you can reduce it to an array or slice.</p>
<p>You need to maximize your cache usage (L1, L2).</p>
<p>Go does not have a virtual machine, hardware is our platform.</p>
<p>Watch the first three video on CPU Caches/Memory from <a href="https://github.com/ardanlabs/gotraining">here</a></p>
<pre><div style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code class="language-golang" style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>for i, fruit := range fruits {
</span>    fmt.Println(i, fruit)
<!-- -->}</code></div></pre>
<p>This is the value semantic version of a for loop.
It means that fruit points to an element of a copy of fruits.</p>
<p><em>Guideline #1</em>: Use value semantics for built-in types when you&#x27;re passing around parameters unless you need the idea of null then use a pointer.</p>
<p>We are going to focus on consistency, easy to read. We don&#x27;t have any issue ad the moment with performance until the tools say we have a performance problem.</p>
<p><em>Guideline #2</em>: When you move a reference type around your program, you have to use the Value semantics. (struct, interface, arrays and slices).</p>
<pre><div style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code class="language-golang" style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>var data []string // slice
</span>var data [6]string // array</code></div></pre>
<p>This is different:</p>
<pre><div style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code class="language-golang" style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>var data []string // nil slice
</span>data := []string{} // empty slice
<!-- -->var es struct{} // empty struct, if you create 100 of those, they will share the same address, no memory consumption</code></div></pre>
<p>In go we have a separation of state and behavior. That data has a behavior it&#x27;s an exception (I don&#x27;t really agree).
Methods can have pointer and value receiver.</p>
<pre><div style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd;padding:1em;margin:.5em 0;overflow:auto"><code class="language-golang" style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#2a2734;color:#9a86fd"><span>func (u user) notify() { // value receiver
</span>    fmt.Prinf(&quot;send %s %s&quot;, u.name, u.email)
<!-- -->}
<!-- -->func (u *user) changeEmail() { // pointer receiver
<!-- -->    u.email = &quot;ciao&quot;
<!-- -->}</code></div></pre>
<p>For factory function the return is the struct itself.
The Time struct use always value semantics, the only pointer semantic is in Unmarshall, Decode methods.
If you choose Value semantics, always use Value semantics for receivers of methods (besides unmarshall and decode).</p>
<p>Polymorphism means that a piece of code changes its behavior depending on the concrete data it operates on.
Everything is data driven.</p>
<p>An interface can only declare a method set of behavior. It&#x27;s abstract.
There are some requirements for it:</p>
<ul>
<li>if we work with value of type T, only method implemented with value semantics</li>
<li>if we work with value of type *T, method implemented with value and pointer semantics</li>
</ul>
<p>Check on <a href="https://github.com/ardanlabs/gotraining/blob/master/topics/courses/go/language/README.md">language mechanics</a> to see the rest on this topic.</p> </div></article></main><div class="layout_backToHome__9sjx_"><a href="/">← Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"2019-02-13-william-kennedy-ultimate-go-training-workshop-mtc-kbh-notes-1day","c":"# [Workshop Link](https://github.com/ardanlabs/gotraining)\n\n- external latency will give you problems\n- microservices is a people problem, not a technical problem\n- garbage collection will give you a problem in performance but you need it\n- internal latency due to syncronization\n- how you acess data will affect your performance\n- logs will give you observability\n\n*DO NOT USE A DEBUGGER, USE OBSERVABILITY.*\nDevelop a mental mode of your code, don't use a debugger, use a logs.\n\nThe go runtime is not a VM, it has many stuff (like gc) but it's not a VM.\n\n- first priority integrity\n- second priority is to avoid to consume resources\n\nWhen you mutate memory =\u003e when bugs happen.\n\nGo syntax comes from Pascal syntax.\n\nWill work with the value of the data and with the value of the address of that data.\nData is both value and address.\n\nYou have both value semantics and pointer semantics.\nValue semantics means that every piece of code has is own copy, data locality comes from value semantics.\n\nWith value semantics we can isolate mutation.\n\nValue semantics will come at a cost, it will be inefficient.\nWith pointer semantics you have side effects but it's more efficient.\n\nGo always pass by copy, but you can pass the value of the address by copy.\n\nFactory functions to create structs\n\n## V1\n\n```golang\nfunc createUserV1() user { // We're using value semantic\n    u := user { name: \"bill\", email: \"something@mail.com\"}\n    return u\n}\n```\n\n## V2\n\n```golang\nfunc createUserV1() *user { // We're using pointer semantic\n    u := user { name: \"bill\", email: \"something@mail.com\"}\n    println(\"V2\", \u0026u)\n    return \u0026u\n}\n```\n\nConstruction on line 47, you don't know where the construction is.\nOn line 48 we are sharing down on the call stack so it's safe.\nWhat happens when we go up? (line 49)\nOn line 49 we are putting the variable on the heap because it's pointer semantics.\nWe should avoid the non productive allocations.\nTthe garbage collection will get involved.\n\nDon't use empty literal constructions, use `var` declaration for zero values struct construction.\n\nDon't do\n\n```golang\nfunc a() *user {\n    a := \u0026model{}\n    return a\n}\n```\n\nat construction time. It hides stuff.\n\nTo understand escape analysis [click here](http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html)\n\nGo doesn't have optimization for recurion nor tail recursion.\n\nWe need to control the gap for garbage collection. We want to use small heap to consume less resources.\nDon't make the gap larger, reduce the memory footprint (because you can reduce it usually).\n\nThe GC uses go routines, so it needs CPU capacity that won't be used by your software.\nThe GC needs to use stop the world time to clean stuff because you can't write while cleaning.\n\nThe go routine needs to go to a safe point before starting a stop the world. (it happens when the gorouting makes a function call)\n\nYou must make user that your code makes function call in a reasonable amount of time.\n\nThe goal is to increase the throughtput in between garbage collection.\nAnother way of doing it is to reduce the pointer semantics.\n\n## How do you access data\n\nWhen you run a benchmark, you machine must be idle, if it's not idle you will have the wrong output. Needs to be idle.\nDon't run benchmark on cloud computers, too much noise.\nFind a value B.N (banchmark value) so that the cycle will be run for the entire benchmark cycle.\nThe hardware also uses value semantics. (L1, L2, L3)\n\nUnless there is no good reason, always use slice of values to give memory continuity.\nWe always use use slices and array and there is no linked list because slice and array are performant.\n\nYou can use whatever structure you want, but when you need optmization, you can reduce it to an array or slice.\n\nYou need to maximize your cache usage (L1, L2).\n\nGo does not have a virtual machine, hardware is our platform.\n\nWatch the first three video on CPU Caches/Memory from [here](https://github.com/ardanlabs/gotraining)\n\n```golang\nfor i, fruit := range fruits {\n    fmt.Println(i, fruit)\n}\n```\n\nThis is the value semantic version of a for loop.\nIt means that fruit points to an element of a copy of fruits.\n\n*Guideline #1*: Use value semantics for built-in types when you're passing around parameters unless you need the idea of null then use a pointer.\n\nWe are going to focus on consistency, easy to read. We don't have any issue ad the moment with performance until the tools say we have a performance problem.\n\n*Guideline #2*: When you move a reference type around your program, you have to use the Value semantics. (struct, interface, arrays and slices).\n\n```golang\nvar data []string // slice\nvar data [6]string // array\n```\n\nThis is different:\n\n```golang\nvar data []string // nil slice\ndata := []string{} // empty slice\nvar es struct{} // empty struct, if you create 100 of those, they will share the same address, no memory consumption\n```\n\nIn go we have a separation of state and behavior. That data has a behavior it's an exception (I don't really agree).\nMethods can have pointer and value receiver.\n\n```golang\nfunc (u user) notify() { // value receiver\n    fmt.Prinf(\"send %s %s\", u.name, u.email)\n}\nfunc (u *user) changeEmail() { // pointer receiver\n    u.email = \"ciao\"\n}\n```\n\nFor factory function the return is the struct itself.\nThe Time struct use always value semantics, the only pointer semantic is in Unmarshall, Decode methods.\nIf you choose Value semantics, always use Value semantics for receivers of methods (besides unmarshall and decode).\n\nPolymorphism means that a piece of code changes its behavior depending on the concrete data it operates on.\nEverything is data driven.\n\nAn interface can only declare a method set of behavior. It's abstract.\nThere are some requirements for it:\n\n- if we work with value of type T, only method implemented with value semantics\n- if we work with value of type *T, method implemented with value and pointer semantics\n\nCheck on [language mechanics](https://github.com/ardanlabs/gotraining/blob/master/topics/courses/go/language/README.md) to see the rest on this topic.","title":"William Kennedy - Ultimate Go Training - Workshop@MTC-KBH - notes day 1","date":"2019-02-13"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2019-02-13-william-kennedy-ultimate-go-training-workshop-mtc-kbh-notes-1day"},"buildId":"z8YvEejwlsmElDyNOqCaY","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>