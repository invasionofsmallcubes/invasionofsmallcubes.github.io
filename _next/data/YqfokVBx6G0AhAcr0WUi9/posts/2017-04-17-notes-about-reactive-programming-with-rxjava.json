{"pageProps":{"postData":{"id":"2017-04-17-notes-about-reactive-programming-with-rxjava","c":"Central to RxJava is the `Observable` type that represents a stream of data or events.\n\nThe entire point of RxJava being reactive, is to support push. To support push `Observable` and `Observer` connect via subscription.\n\n```\ninterface Observable<T> {\n  Subscription subscribe(Observer s);\n}\n```\n\nOnce subscription is made, streams of data are handled using the following interface\n\n```\ninterface Observer<T> {\n  void onNext(T t);\n  void onError(Throwable t);\n  void onCompleted();\n}\n```\n\n`onError` and `onCompleted` are terminal events and only one of them can happen (if the stream is not infinite).\n\nAn `Observable`, by default, is synchronous. Although it's bad to use an Observable with synchronous blocking I/O. It's generally not always wrong to use a synchronous `Observable`. For example, if we retrieve data from a cache, it doesn't make sense to add complexity to the code with asynchronous behavior because a cache has a lookup time of micro/nano seconds.\n\nThe actual criteria to decide about how we should implement our `Observable`, is whether the event production is blocking or not blocking.\n\nThat being said, most `Observable` functions pipeline are synchronous (map, filter, ...) because we want to produce the event stream but then we want to run computation on them. This will guarantee us efficiency and will avoid nondeterministic behavior due to scheduling, context switching and so on.\n\nParallelism is simultaneous execution of tasks, tipically on different CPUs or machines. Concurrency, on the other hand, is the composition or interleaving of multiple tasks.\n\nThe contract of `Observable` is that events (`onNext()`, `onCompleted()`,`onError()`) can never be emitted concurrently. Allowing concurrent `Observable` streams (with concurrent `onNext()`) would limit the types of events that can be processed and required thread-safe data structures. Is also slower to do generic fine-grained parallelism.\n\nIt is far more efficient to synchronously execute on a single thread and take advantage of the many memory and CPU optimizations for sequential computation. On a list is quite is to reason in this way but a stream does not know the work ahead of time, it just receives data via `onNext()` and therefore cannot automatically chunk the work.\n\nThe `Observable` type is lazy, meaning it does nothing until it is subscribed to. With lazyiness is possible to compose `Observable` together. Creating one does not actually cause any work to happen. The work will happen once subscribed. Being lazy also allows that a particular instance can be invoked more than once.\n\nAn `Observable` is the *dual* of an `Iterable`. It push instead of pull. Besides that, the same programming model can be applied by both:\n\n```\ngetDataFromMemory(). // return Stream<String>\n// OR\ngetDataAsynch(). // Observable<String>\n.skip(10)\n.limit(5)\n.map(s -> s + \"_transformed\")\n.forEach(System::out::println)\n```\n\n`rx.Observable<T>` is the abstraction is going to be used all the time. An `Observable` can produce an\narbitrary number of events. It can produce:\n- Values of type T, as declared by `Observable`\n- Completion events\n- Error event\n\nAn instance of `Observable` does not emit any events until someone is actually interested in receiving them (this are called *cold* `Observable`).\n\n```\ntweets.subscribe(\n    (Tweet tweet) -> { System.out.println(tweet); },\n    (Throwable t) -> { t.printStackTrace(); }\n  );\n```\n\nIt's guaranteed that no other Tweet will be emitted after the exception.\n\nBy default Observable runs on current thread if not otherwise specified:\n\n```\nObservable<Integer> ints = Observable.create(\n        subscriber -> {\n            log(\"CREATE\");\n            subscriber.onNext(5);\n            subscriber.onNext(6);\n            subscriber.onNext(7);\n            subscriber.onCompleted();\n            log(\"COMPLETED\");\n        }\n);\nlog(\"STARTING\");\nints.subscribe( i -> log(\"Element\"+ i) );\nlog(\"FINISHED\");\n```\n\nThis will print out:\n\n```\nmain: STARTING\nmain: CREATE\nmain: Element5\nmain: Element6\nmain: Element7\nmain: COMPLETED\nmain: FINISHED\n```\n\nWe can implement others `Observable` constructors as `create`:\n\n```\nstatic <T> Observable<T> just(T t) {\n    return Observable.create(\n            s -> {\n                s.onNext(t);\n                s.onCompleted();\n            }\n    );\n}\n\nstatic <T> Observable<T> never() {\n    return Observable.create(\n            s -> {}\n    );\n}\n\nstatic <T> Observable<T> empty() {\n    return Observable.create(\n            s -> {\n                s.onCompleted();\n            }\n    );\n}\n\nstatic Observable<Integer> range(Integer from, Integer to) {\n    return Observable.create(\n            s -> {\n                IntStream.range(from, to).forEach( i -> s.onNext(i));\n                s.onCompleted();\n            }\n    );\n}\n```\n\nEvery time we call `subscribe()`, the subscrition handler inside `create` is invoked. If you want to avoid call\ncreate every time, you can use `cache()` that will give events already computed. Of course if stream is infinite, using `cache()` will kill a kitten.\n\nTo produce infinite streams it's not really convenient calling the computation inside the client thread, but rather start a new thread that will handle the computation. For how long should we keep computing stuff?\n\nIt is advised to use the method `isUnsubscribed()` to check if we have subscribers listening:\n\n```\nstatic Observable<BigInteger> naturalNumbers() {\n    return Observable.create(\n            s -> {\n                Runnable r = () -> {\n                    BigInteger i = BigInteger.ZERO;\n                    while(!s.isUnsubscribed()) {\n                        s.onNext(i);\n                        i = i.add(BigInteger.ONE);\n                    }\n                };\n                Thread thread = new Thread(r);\n                thread.start();\n                s.add(Subscriptions.create(thread::interrupt));\n            });\n}\n```\n\n```\nSubscription subscribe = naturalNumbers()\n        .subscribe(System.out::println,\n          e -> System.out.println(e.getMessage())); // not triggered\n\n// do something else [...]\n\n    subscribe.unsubscribe();\n```\n\nBetween the check of isUnsubscribed and the actual computation we could have also seconds to wait because the computation could be really big.\n\nPassing thread::interrupt to the subscription allows you to quit as soon as possible without wasting time.\nBe Aware that this will not trigger the `onError`. Subscription will end gracefully.\n\nYou cannot call the `onNext` from multiple threads. Don't do it, it violates Rx principles.\n\nThe class `Observable` has two useful methods: `timer` and `interval`.\n\nThe first one is like the method `sleep`, the latter instread emits at a fixed rate some element.\n\nA cold `Observable` is lazy and doesn't emits until someone subscribes. This implies that every subscriber has its own copy of the stream because for every subscription the method `create` as mentioned above. Generally speaking a cold `Observable` involves some side effect like connecting to a database.\n\nHot `Observable` are independent from consumers, they emits even if there is no subscriber. At a certain point, when a subscriber subscribes, it will receive events that are being currently being emitted. An example of hot `Observable` is for example mouse events.\n\nAn example of hot subscriber can be seen via the method `publish` from `Observable`.\nAn example of what (to me seems) an almost cold subscriber can be seen via `share()`.\n\nGiven:\n\n```\nprivate static void refCount(Observable<Status> observable) {\n    Observable<Status> observable1 = observable.share(); // or observable.publish().refCount();\n\n    System.out.println(\"Subscribe1\");\n    Subscription subscribe1 = observable1.subscribe();\n\n    System.out.println(\"Subscribe2\");\n    Subscription subscribe2 = observable1.subscribe();\n\n    System.out.println(\"Unsubscribe1\");\n    subscribe1.unsubscribe();\n\n    System.out.println(\"Unsubscribe2\");\n    subscribe2.unsubscribe();\n\n}\n\nprivate static void publish(Observable<Status> observable) {\n    ConnectableObservable<Status> publish = observable.publish();\n\n    System.out.println(\"Subscribe1\");\n    Subscription subscribe1 = publish.subscribe();\n\n    System.out.println(\"Subscribe2\");\n    Subscription subscribe2 = publish.subscribe();\n\n    Subscription connect = publish.connect();\n\n    System.out.println(\"Unsubscribe1\");\n    subscribe1.unsubscribe();\n\n    System.out.println(\"Unsubscribe2\");\n    subscribe2.unsubscribe();\n\n    System.out.println(\"Disposing connection\");\n    connect.unsubscribe();\n}\n```\n\nRunning:\n\n```\nSystem.out.println(\"with Share:\");\nrefCount(observable);\nSystem.out.println(\"\");\nSystem.out.println(\"with Publish:\");\npublish(observable);\n```\n\nYou get this output:\n\n```\nwith Share:\nSubscribe1\nConnecting...\nSubscribe2\nUnsubscribe1\nUnsubscribe2\nDisconnecting...\n\nwith Publish:\nSubscribe1\nSubscribe2\nConnecting...\nUnsubscribe1\nUnsubscribe2\nDisposing connection\nDisconnecting...\n```\n\nThere are many operators.\n\nOne interesting thing is:\n\n```\nSystem.out.println(\"SCAN\");\nObservable.just(1,2,3).scan((total, chunk) -> total+chunk).subscribe(out::println);\nSystem.out.println(\"REDUCE\");\nObservable.just(1,2,3).reduce((total, chunk) -> total+chunk).subscribe(out::println);\n```\n\nand the output is:\n\n```\nSCAN\n1\n3\n6\nREDUCE\n6\n```\n\nKeep in mind that in case of infinite stream `scan` will keep emitting whereas reduce will never emit. If we use `distinct`, this will cause problems because it caches every event generated.\n\nYou can do this: `concat(fromCache, fromDb).first()` and just call `fromDb` only when element is not present in cache!! (`concat is lazy!`)\n\n```\nObservable<String> fromCacheEmpty = Observable.empty();\nObservable<String> fromCacheOneElem = Observable.just(\"1\");\nObservable<String> fromCacheNElem = Observable.just(\"1\", \"3\");\nObservable<String> fromDb = Observable.just(\"2\");\n\nSystem.out.println(\"EMPTY -> DB\");\nObservable.concat(fromCacheEmpty, fromDb).first().subscribe(out::println);\nSystem.out.println(\"CACHE1 -> NODB\");\nObservable.concat(fromCacheOneElem, fromDb).first().subscribe(out::println);\nSystem.out.println(\"CACHE2 -> DB\");\nObservable.concat(fromCacheNElem, fromDb).first().subscribe(out::println);\n```\n\nwith output:\n\n```\nEMPTY -> DB\n2\nCACHE1 -> NODB\n1\nCACHE2 -> DB\n1\n```\n\nRead on the chapter about `concat`, `merge` and `switchOnNext` starting on page 97. It's so cool.\n\nWant to do event sourcing with RxJava? Done!\n\n```\neventStore\n.observe()\n.groupBy(event::uuid)\n.subscribe( uuid -> uuid.subscribe(this::updateProjection));\n```\n\nYou can use `observeOn` and `subScribeOn` to move on different thread the computation and the subscription of your flow of data. `subscribeOn` allows you to tell on which thread you want to push events down to your stream. A common use case is to process the stream on the the background but emit it on another thread (common example is to do heavy computation on the backend and observe on the UI thread). In this case you can use the `observeOn` method.\n\nYou can also achieve parallelism with this feature but keep in mind that you need to take care of how much parallelism your system can handle. `flatMap` method has an overloaded method that allows you to control parallelism. You have many `Schedulers` from which you can get threads. Remember that `io()` will spawn new threads if existing ones are being used whereas `computation()` has CPU-bound threads.\n\nTo recap:\n\n* `Observable` without `subscribeOn` will work like a single threaded program with blocking calls\n* `Observable` with `subscribeOn` will start a thread on background where the work is done (inside the thread still sequential calls)\n* `Observable` using `flatMap` and inside it `subscribeOn` will start a new thread for each `Observable`\n\nAnother concept really important with reactive programming is *backpressure*. In every system based on message passing, the problem of the consumer not\nconsuming fast enough can be present. If the consumer is able to give a feedback to the producer, the producer now can control how much it's producing (although if you have a hot producer, that could be not true).\n\nMany operators have backpressure built-in so there is no need to worry about it. If you have to produce from scratch a producer, you can use `SyncOnSubscribe.createStatless|createStateful` (there is also the Async version). Don't use `create` from `Observable` because you won't have backpressure on it.\n\nTo know about testing, you can read about it [here](https://www.infoq.com/articles/Testing-RxJava)\n","title":"Notes About Reactive Programming With RxJava","date":"2017-04-17"}},"__N_SSG":true}