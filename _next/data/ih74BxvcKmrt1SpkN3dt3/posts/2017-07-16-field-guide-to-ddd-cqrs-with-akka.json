{"pageProps":{"postData":{"id":"2017-07-16-field-guide-to-ddd-cqrs-with-akka","c":"## Notes on \"field Guide to DDD/CQRS with Akka\"\n\nThis is are the notes as seen on this talk at Devoxxx Belgium:\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/fQkKu4tTgCE?rel=0&amp;controls=0&amp;showinfo=0\" frameborder=\"0\" allowfullscreen></iframe>\n\nLet's begin\n- aggregate is responsible for consistency *(DDD)*\n- you can only modify one aggregate per transaction *(DDD)*\n- write model receives commands and produce events *(CQRS)*\n- strict consistency on write model side *(DDD/CQRS)*\n- read models are created from events *(CQRS)*\n- eventual consistency if asynch *(CQRS/ES)*\n- events can be stored and replayed (ES)\n\nNow we will se what operation we should implement for CQRS (in a non-reactive way)\n\n```scala\ntrait DomainCommand\ntrait DomainEvent\ntrait Aggregate\n\ntrait Behavior {\n  // this is part of the constructor\n  // it has to validate the DomainComman then it produces an event\n  // only if DomainCommand is valid\n  def validate(cmd: DomainCommand) : DomainEvent\n\n  // once the first event is created we use this method to creat an aggregate\n  def applyEvent(evt: DomainEvent) : Aggregate\n\n  // we have to separate method because:\n  // 1) we want to write code between validation and application of an event\n  // 2) in case of replay, we don't have commands, just events\n\n  // this method validates a command against an existing aggregate\n  def validate(cmd: DomainCommand, agg: Aggregate) : DomainEvent\n\n  // application of an event on the aggregate\n  // aggregate is immutable, so we produce a new aggregate every time we use this apply event\n  def applyEvent(evt: DomainEvent, agg: Aggregate) : Aggregate\n}\n```\n\nIn Akka the main component is a `PartialFunction[Any,Unit]` that will consume any type and will return a `Unit` . It's too broad and we know, given a command in input, which domain we will produce.\n\nAkka is an actor system. We send messages to an *actor* which we cannot manipulate directly, we use its `ActorRef`.\n\nThe message will go to the `Actor` mailbox and the `Actor` will consume it when it is ready to do so.\n\nAn `Actor`can have an internal mutable state but it cannot be accessed from outside.\n\nAn `Actor` stays in memory until dies or it's terminated. With `Akka Persistence` we can save the events we send after processing a message and so we can then recover a state.\n\nAn `Actor` has a receive method that can handle messages that comes from the system. If that `Actor` will receive a message it cannot handle, will just ignore it. It will send it to a *dead letter queue*.\n\nThe `Actor` will collect messages in the `Mailbox` until it is not ready to read another one. In the `Mailbox` messages are kept in order of arrival. `Akka` will guarantee it for you.\n\nWith event sourcing you have first to persist the event generated from a command (the message) using the Behavior trait and after that I can finally apply that command to the aggregate.\n\nThe `AggregateManager` is the entry point for a given Aggregate type. It forwards message to the correct Aggregate based on the id. It also stops children according to a *passivation strategy*.\n\nIn `Akka Persistence` you can have snapshots.\n\n`Akka` being a `PartialFunction` that goes from `Any` to `Unit` is to broad and doesn't respect our domain. So we want to define something more stricter, done specifically for our domain.\n\nWe give to the scala compiler the responsibility about signaling if something is wrong about the usage of my commands and events.\n\n```scala\ntrait ProtocolDef {\n  trait ProtocolCommand extends DomainCommand\n  trait ProtocolEvent extends DomainEvent\n}\n\ntrait Aggregate {\n  type Protocol <: ProtocolDef\n  // type member (similar to type parameter)\n  // a type member can be referenced and so\n  // you can navigate your type\n}\n\nobject ProductProtocol extends ProtocolDef {\n  case class CreateProduct ... extends ProtocolCommand\n  case class ProductCreate ... extends ProtocolEvent\n}\n\ncase class Product(...) extends Aggregate {\n  type Protocol = ProductProtocol.type\n  // so aggregate Product responds to\n  // protocol of type ProductProtocol\n  // they are bounded\n}\n\ntrait Behavior[ A <: Aggregate ] {\n  type AggregateType : A\n  type Command: AggregateType#Protocol#ProtocolCommand\n  type Event = AggregateType#Protocol#Protocolvent\n\n  // AggregateType bounds Command and Event to be only of that type\n  // you will have compile error\n\n  def validate(cmd: Command) : Event\n  def applyEvent(evt: Event) : AggregateType\n}\n```\n\nWith this strategy we use the type system in our favour to create a sound domain.\n\nNow we want to make our behavior more reactive.\n\n```scala\ndef validate(cmd: Command) : Future[DomainEvent]\n```\n\nWith `Future` the problem is that some command can take more time than another one so there could be a problem with order arrival of a `DomainEvent`. A `Future` will return instantly so the actor will consume the next message from the mailbox.\n\nWe can have two types of aggregate:\n\n- **Authoritative**: can validate everything it receives grabbing information from other systems\n- **Authomonus**: can validate everything it receives without the necessity to ask outside of itself\n\nAggregate needs to be open to async programming.\n\n```scala\ndef validate(cmd: Command) : Future[Seq[DomainEvent]]\n```\n\nOne command can also release more than one event.\n\nNever apply an event async. Always sync!\n\nThe read model needs to work the same way as the write model, so it has to process one event ad the time in a stream. There is a `ProjectionActor` that subscribe to a stream (with `Akka Persistence Query`) and until the Projection has finished applying that event, it won't work on another one. `ProjectionActor` is responsible for doing backpressure on the stream.\n\nGenerally you have one `Actor` per `AggregateId`.\n\nTo handle, let's say, with good performance, all the commands end events, it's good to return a `Future` instead of the value so that you can process them in a different executor. This aims to not overwhelm the actor system executor with *business logic* work. To do that, you need to *switch* the nature of your Actor from *normal* (when it is able to process every event) to *busy* meaning that it doesn't process anything until the previous task has ended.\n\nThis is the `Busy` state:\n\n```scala\n  private def busy: Receive = {\n    val busyReceive: Receive = {\n      case Successful(events, nextState, origSender) => onSuccess(events, nextState, origSender)\n      case failedCmd: FailedCommand                  => onFailure(failedCmd)\n      case TypedCommand(cmd) =>\n        log.debug(\"aggregate '{}' received {} while processing another command\", identifier, cmd)\n        stash()\n    }\n    defaultReceive orElse busyReceive\n  }\n```\n\nThis is the `Available` state:\n\n```scala\n    val receive: Receive = {\n      case TypedCommand(cmd) =>\n        log.debug(\"aggregate '{}' received cmd: {}\", identifier, cmd)\n        val eventualTimeout =\n          after(duration = commandTimeout, using = context.system.scheduler) {\n            Future.failed(new TimeoutException(s\"Async command took more than $commandTimeout to complete: $cmd\"))\n          }\n        val eventualEvents = interpreter.applyCommand(aggregateState, cmd)\n        val eventWithTimeout = Future firstCompletedOf Seq(eventualEvents, eventualTimeout)\n        val origSender = sender()\n        eventWithTimeout map {\n          case (events, nextState) => Successful(events, nextState, origSender)\n        } recover {\n          case NonFatal(cause) => FailedCommand(cmd, cause, origSender)\n        } pipeTo self\n        changeState(Busy)\n    }\n```\n\nAs taken from the library [`fun.CQRS`](https://github.com/strongtyped/fun-cqrs) discussed in the talk.\n","title":"Field Guide to DDD/CQRS With Akka","date":"2017-07-16"}},"__N_SSG":true}