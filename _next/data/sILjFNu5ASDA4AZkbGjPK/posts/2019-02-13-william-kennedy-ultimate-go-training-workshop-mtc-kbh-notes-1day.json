{"pageProps":{"postData":{"id":"2019-02-13-william-kennedy-ultimate-go-training-workshop-mtc-kbh-notes-1day","c":"# [Workshop Link](https://github.com/ardanlabs/gotraining)\n\n- external latency will give you problems\n- microservices is a people problem, not a technical problem\n- garbage collection will give you a problem in performance but you need it\n- internal latency due to syncronization\n- how you acess data will affect your performance\n- logs will give you observability\n\n*DO NOT USE A DEBUGGER, USE OBSERVABILITY.*\nDevelop a mental mode of your code, don't use a debugger, use a logs.\n\nThe go runtime is not a VM, it has many stuff (like gc) but it's not a VM.\n\n- first priority integrity\n- second priority is to avoid to consume resources\n\nWhen you mutate memory => when bugs happen.\n\nGo syntax comes from Pascal syntax.\n\nWill work with the value of the data and with the value of the address of that data.\nData is both value and address.\n\nYou have both value semantics and pointer semantics.\nValue semantics means that every piece of code has is own copy, data locality comes from value semantics.\n\nWith value semantics we can isolate mutation.\n\nValue semantics will come at a cost, it will be inefficient.\nWith pointer semantics you have side effects but it's more efficient.\n\nGo always pass by copy, but you can pass the value of the address by copy.\n\nFactory functions to create structs\n\n## V1\n\n```golang\nfunc createUserV1() user { // We're using value semantic\n    u := user { name: \"bill\", email: \"something@mail.com\"}\n    return u\n}\n```\n\n## V2\n\n```golang\nfunc createUserV1() *user { // We're using pointer semantic\n    u := user { name: \"bill\", email: \"something@mail.com\"}\n    println(\"V2\", &u)\n    return &u\n}\n```\n\nConstruction on line 47, you don't know where the construction is.\nOn line 48 we are sharing down on the call stack so it's safe.\nWhat happens when we go up? (line 49)\nOn line 49 we are putting the variable on the heap because it's pointer semantics.\nWe should avoid the non productive allocations.\nTthe garbage collection will get involved.\n\nDon't use empty literal constructions, use `var` declaration for zero values struct construction.\n\nDon't do\n\n```golang\nfunc a() *user {\n    a := &model{}\n    return a\n}\n```\n\nat construction time. It hides stuff.\n\nTo understand escape analysis [click here](http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html)\n\nGo doesn't have optimization for recurion nor tail recursion.\n\nWe need to control the gap for garbage collection. We want to use small heap to consume less resources.\nDon't make the gap larger, reduce the memory footprint (because you can reduce it usually).\n\nThe GC uses go routines, so it needs CPU capacity that won't be used by your software.\nThe GC needs to use stop the world time to clean stuff because you can't write while cleaning.\n\nThe go routine needs to go to a safe point before starting a stop the world. (it happens when the gorouting makes a function call)\n\nYou must make user that your code makes function call in a reasonable amount of time.\n\nThe goal is to increase the throughtput in between garbage collection.\nAnother way of doing it is to reduce the pointer semantics.\n\n## How do you access data\n\nWhen you run a benchmark, you machine must be idle, if it's not idle you will have the wrong output. Needs to be idle.\nDon't run benchmark on cloud computers, too much noise.\nFind a value B.N (banchmark value) so that the cycle will be run for the entire benchmark cycle.\nThe hardware also uses value semantics. (L1, L2, L3)\n\nUnless there is no good reason, always use slice of values to give memory continuity.\nWe always use use slices and array and there is no linked list because slice and array are performant.\n\nYou can use whatever structure you want, but when you need optmization, you can reduce it to an array or slice.\n\nYou need to maximize your cache usage (L1, L2).\n\nGo does not have a virtual machine, hardware is our platform.\n\nWatch the first three video on CPU Caches/Memory from [here](https://github.com/ardanlabs/gotraining)\n\n```golang\nfor i, fruit := range fruits {\n    fmt.Println(i, fruit)\n}\n```\n\nThis is the value semantic version of a for loop.\nIt means that fruit points to an element of a copy of fruits.\n\n*Guideline #1*: Use value semantics for built-in types when you're passing around parameters unless you need the idea of null then use a pointer.\n\nWe are going to focus on consistency, easy to read. We don't have any issue ad the moment with performance until the tools say we have a performance problem.\n\n*Guideline #2*: When you move a reference type around your program, you have to use the Value semantics. (struct, interface, arrays and slices).\n\n```golang\nvar data []string // slice\nvar data [6]string // array\n```\n\nThis is different:\n\n```golang\nvar data []string // nil slice\ndata := []string{} // empty slice\nvar es struct{} // empty struct, if you create 100 of those, they will share the same address, no memory consumption\n```\n\nIn go we have a separation of state and behavior. That data has a behavior it's an exception (I don't really agree).\nMethods can have pointer and value receiver.\n\n```golang\nfunc (u user) notify() { // value receiver\n    fmt.Prinf(\"send %s %s\", u.name, u.email)\n}\nfunc (u *user) changeEmail() { // pointer receiver\n    u.email = \"ciao\"\n}\n```\n\nFor factory function the return is the struct itself.\nThe Time struct use always value semantics, the only pointer semantic is in Unmarshall, Decode methods.\nIf you choose Value semantics, always use Value semantics for receivers of methods (besides unmarshall and decode).\n\nPolymorphism means that a piece of code changes its behavior depending on the concrete data it operates on.\nEverything is data driven.\n\nAn interface can only declare a method set of behavior. It's abstract.\nThere are some requirements for it:\n\n- if we work with value of type T, only method implemented with value semantics\n- if we work with value of type *T, method implemented with value and pointer semantics\n\nCheck on [language mechanics](https://github.com/ardanlabs/gotraining/blob/master/topics/courses/go/language/README.md) to see the rest on this topic.","title":"William Kennedy - Ultimate Go Training - Workshop@MTC-KBH - notes day 1","date":"2019-02-13"}},"__N_SSG":true}