{"pageProps":{"postData":{"id":"2019-02-14-william-kennedy-ultimate-go-training-workshop-mtc-kbh-notes-day-2","c":"\nDon't use interfaces in the first place, discover them while refactoring.\nDon't repeat yourself sometimes it's more harmful than anything.\n\nWrite the first thing that it's easy, don't worry about optimization now.\n\n```golang\nfunc (*Xenia) Pull() (*Data, error)\n```\nthis will put data on the heap\n\n```golang\nfunc (*Xenia) Pull(d *Data) error\n``` \nthis will not put data in heap, but will keep in the stack.\n\nNow I finally understood why marshall and decode have the return element in the argument.\n\nAfter we see that the system is stable, when we need to add a new behavior, then we introduce the interface.\n\nDon't define alias as \n```golang\ntype Handle int\n``` \nIf you have to explaining it using \n```golang\nint\n``` \nthen it's a real use type.\n```golang\ntype Duration int64\n``` \nmakes sense because you can explain like **that represents a nanosecond of time**\n\nFor the rest check [here](https://github.com/ardanlabs/gotraining/blob/master/topics/courses/go/design/README.md)\n\nYou need to understand your workload to understand before starting writing for concurrency. You have CPU bound workload and IO bound workload.\n\nCPU bound workload is when you have an algorithm that doesn't move your thread from running to waiting state, only an external event could do that (OS scheduler)\n\nIO bound workload is a workload that will move from running to waiting, you run operation on OS, open a file for example, use mutexes.\n\nCPU bound workload is the more efficient work you can do.\n\nNever use more or less threads than the number of hardware threads you have.\n\nEvery OS has a thread pooling technology. You put the request into the pools and try to do the work with the less number of threads possible.\n\nWhat causes a scheduling decision:\n\n- go function\n- GC\n- syscall (async/sync)\n    -- networking in go is really fast\n\nA runtime will use work stealing algorithms.\n\nChannels are slow, they're filled with latency costs. We need to use them with careful attention. Avoid the use of WaitGroups for performance reasons but you should use them to track the work that has been done.\n\nTo find race conditions, you can run \n```bash\ngo build -race\n``` \nor you can use the also go test \n```bash\ngo test -race -cpu 24\n```\nwith extra threads.\n\nFor the rest check [here](https://github.com/ardanlabs/gotraining/blob/master/topics/courses/go/concurrency/README.md)","title":"William Kennedy - Ultimate Go Training - Workshop@MTC-KBH - Notes Day 2","date":"2019-02-14"}},"__N_SSG":true}